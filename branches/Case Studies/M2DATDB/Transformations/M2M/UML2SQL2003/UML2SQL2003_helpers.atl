-- @atlcompiler atl2006
-- @nsURI 		UML=http://www.eclipse.org/uml2/2.1.0/UML
-- @nsURI 		SQL2003=http://SQL2003.ecore
-- @path 		AMW=/UML2SQL2003/Metamodels/ORAnnotationMeta.ecore

--BEGIN DOC
--#About
-- @name 		UML2SQL2003_helpers
-- @version		1.0
-- @domains		database, dsl, sql2003, uml, mda, amw, transformation,
--				metamodel, model
-- @authors		Alejandro Galindo (Universidad Rey Juan Carlos)
-- @date       	24-03-2009
-- @description	Esta librería ATL contiene los helpers utilizados en las
--				transformaciones realizadas	desde un modelo conforme 
--				al metamodelo UML con ATL a un modelo de salida conforme
--				al metamodelo SQL2003, teniendo en cuenta las anotaciones
--              del modelo de weaving definidas con AMW. Éstas recogen las
--              decisiones de diseño a aplicar.
--END DOC

library UML2SQL2003_helpers;

-------------------------------------------------------------------------------
-- CONSTANTS       ------------------------------------------------------------
-------------------------------------------------------------------------------

--BEGIN DOC
--#DESCRIPTION
--Constante que almacena las propiedades multivaluadas del modelo de entrada.
--
--@LIBRARIES UML_constants
--END DOC
helper def : CLASS_MULTIVALUED_PROPERTIES() : Sequence(UML!Property) =
	thisModule.CLASS_PROPERTIES()->select(prop | 
			prop.isFixedSizeMultivaluedAttribute() or 
			prop.isVarSizeMultivaluedAttribute()
	);

--BEGIN DOC
--#DESCRIPTION
--Constante que almacena los extremos de las asociaciones que dan como resultado
--un atributo que referencia a una clase.
--
--@LIBRARIES UML_constants
--END DOC
helper def : MEMBERS_END_2_CLASS_REF() : Sequence(UML!Property) =
	thisModule.MEMBERS_END()->select(prop | 
		(
			prop.isCardinalZeroOne() or
			prop.isCardinalOneOne()
		)
		and
		(
			prop.isAssociationSimple() or
			prop.isAssociationNavigable()
		)
	);

--BEGIN DOC
--#DESCRIPTION
--Constante que almacena los extremos de las asociaciones que dan como resultado
--un atributo de tipo colección de una clase.
--
--@LIBRARIES UML_constants
--END DOC
helper def : MEMBERS_END_2_CLASS_COLLECTION() : Sequence(UML!Property) =
	thisModule.MEMBERS_END()->select(prop | 
		(
			prop.isCardinalZeroMulti() or
			prop.isCardinalZeroN() or
			prop.isCardinalOneMulti() or
			prop.isCardinalOneN() or
			prop.isCardinalMultiN()
		)
		and
		(
			prop.isComposition()
		)
	);

--BEGIN DOC
--#DESCRIPTION
--Constante que almacena los extremos de las asociaciones que dan como resultado
--un atributo de tipo colección de referencias a una clase.
--
--@LIBRARIES UML_constants
--END DOC
helper def : MEMBERS_END_2_CLASS_REF_COLLECTION() : Sequence(UML!Property) =
	thisModule.MEMBERS_END()->select(prop | 
		(
			prop.isCardinalZeroMulti() or
			prop.isCardinalZeroN() or
			prop.isCardinalOneMulti() or
			prop.isCardinalOneN() or
			prop.isCardinalMultiN()
		)
		and
		(
			prop.isAssociationSimple() or
			prop.isAssociationNavigable() or
			prop.isAggregation()
		)
	);

-------------------------------------------------------------------------------
-- HELPERS         ------------------------------------------------------------
-------------------------------------------------------------------------------

--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el supertipo del tipo de dato de entrada si lo tiene.
--
--@CONTEXT UML!DataType
--@RETURN UML!DataType
--@LIBRARIES UML
--END DOC
helper context UML!DataType def : getUDTSuperType() : UML!DataType =
	if (self.hasSuperDataType()) then
		self.getFirstSuperDataType()
	else
	 	OclUndefined
	endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve la superclase de la clase de entrada si la tiene.
--
--@CONTEXT UML!Class
--@RETURN UML!Class
--@LIBRARIES UML
--END DOC
helper context UML!Class def : getSuperClass() : UML!Class =
	if (self.hasSuperClass()) then
		self.getFirstSuperClass()
	else
	 	OclUndefined
	endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve la superclase de la clase de entrada si la tiene.
--
--@CONTEXT UML!Property
--@RETURN String
--@LIBRARIES UML2SQL2003_AMW
--END DOC
helper context UML!Property def : getDefaultValueProperty() : String =
	if (self.hasDefaultValueAnnotation()) then
		self.getDefaultValueAnnotation()
	else
		OclUndefined
	endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper indica si la clase de entrada es una superclase con una anotación
--de jerarquía para mapearse a una única tabla.
--
--@CONTEXT UML!Class
--@RETURN Boolean
--@LIBRARIES UML, UML2SQL2003_AMW
--END DOC
helper context UML!Class def : isSuperClassWithOneTableHierarchy() : Boolean =
	(not self.isAbstract) and
	(self.hasSubClasses()) and 
	(self.isMapClassToOneTable());


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve la tabla tipada padre de la tabla tipada que genera
--la clase de entrada.
--
--En UML hay herencia múltiple pero en SQL:2003 sólo hay herencia simple,
--por eso se coge el primer elemento de la generalización nada más
--(sólo puede haber un padre). Además, éste debe ser un elemento 'Class'.
--
--@CONTEXT UML!Class
--@RETURN SQL2003!TypedTable
--@LIBRARIES UML
--END DOC
helper context UML!Class def : getSuperTypedTable() : SQL2003!TypedTable = 
    if (self.hasSuperClass()) then
	
		--Las clases abstractas no generar tablas tipadas
		if ((self.getFirstSuperClass().isAbstract) or
			(not self.getFirstSuperClass().generatesTypedTable())
		) then
			OclUndefined
		else
			thisModule.resolveTemp(self.getFirstSuperClass(),'tt')
		endif
	else
		OclUndefined
 	endif;

 	
--BEGIN DOC
--#DESCRIPTION
--Este helper informa de si la clase de entrada dará lugar a
--una tabla tipada durante el mapeo.
--
--@CONTEXT UML!Class
--@RETURN UML!Boolean
--@LIBRARIES UML2SQL2003_AMW
--END DOC
helper context UML!Class def: generatesTypedTable() : Boolean =
	if (self.isChildOfClassToOneTable()) then 	
		false --Hay anotación diciendo que NO genere tabla
	else
		if (self.hasSpecializationInfo()) then
			not (self.getFirstSpecializationInfo().isCovering())
		else
			true 
			--No hay anotación diciendo que NO genere tabla
			--y no hay decisión sobre como mapear la jerarquía
		endif
	endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper informa de si la clase de entrada dará lugar a
--una tabla tipada 'merging' durante el mapeo
--
--@CONTEXT UML!Class
--@RETURN UML!Boolean
--@LIBRARIES UML, UML2SQL2003_AMW
--END DOC
helper context UML!Class def: generatesMergingTypedTable() : Boolean =
	if (
		self.hasSubClasses() and
		not (
			self.hasHierarchyAnnotation() and
			self.isLastHierarchy()
		)
	) then
		if (self.hasSpecializationInfo()) then 
			not self.isDisjointHierarchy()
		else
			--si no tiene GeneralizationSet, no genera MergingTT
			false
		endif
	else
		--si no tiene hijos o tiene anotación sobre cómo mapear
		--la jerarquía, no genera MergingTT
		false 
	endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper utiliza los dos anteriores para devolver la colección de 
--'TypedTables' que generarán todas las clases que descienden de la 
--clase de entrada
--
--@CONTEXT UML!Class
--@RETURN Sequence(SQL2003!TypedTable)
--@LIBRARIES UML
--END DOC
helper context UML!Class def: getDescendantsTypedTables() : 
		Sequence(SQL2003!TypedTable) =
			
	self.getDescendants()->
		iterate(aux; tts : Sequence(SQL2003!TypedTable)= Sequence{} |
			if (aux.generatesTypedTable()) then
				if (aux.generatesMergingTypedTable()) then
					tts.append(thisModule.resolveTemp(aux, 'tt')).append(
						thisModule.resolveTemp(aux, 'tt_merge'))
				else
					tts.append(thisModule.resolveTemp(aux, 'tt'))
				endif
			else
				if (aux.generatesMergingTypedTable()) then 
					tts.append(thisModule.resolveTemp(aux, 'tt_merge'))
				else
					tts
				endif
			endif
		--Si la clase de entrada genera MergingTypedTable también hay que incluirla  	
		).append(self.getMergingTypedTable()); 

		
--BEGIN DOC
--#DESCRIPTION
--Este helper utiliza una estrategia similar al anterior para construir 
--la consulta que deberá contener la vista que permite recuperar todos 
--los objetos que serán 'oclIsKindOf()' del UDT al que se mapea la 
--clase de entrada.
--
--@CONTEXT UML!Class
--@RETURN String
--END DOC
helper context UML!Class def: getQueryExpression() : String = 
	let exp : String = self.getDescendants()->
		select(c | c.generatesTypedTable() or c.generatesMergingTypedTable())->
			iterate(aux; exp : String = 'SELECT * FROM ' |
				if aux.generatesTypedTable() then
					if aux.generatesMergingTypedTable() then
						exp + aux.getTypedTableName() + ', ' + 
						aux.getMergingTypedTableName()	+ ', '			
					else
						exp + aux.getTypedTableName() + ', '
					endif
				else
					exp + aux.getMergingTypedTableName() + ', '
				endif
			)
	in 
		if self.generatesMergingTypedTable() then
			(exp + self.getMergingTypedTableName()) + ';'
		else
			(exp.substring(1, exp.size()-2) + ';')
		endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el nombre de la tabla tipada que genera la clase de entrada.
--
--@CONTEXT UML!Class
--@RETURN String
--END DOC
helper context UML!Class def: getTypedTableName(): String =
	self.name+'_table';


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el nombre de la tabla tipada de 'merging'
--que genera la clase de entrada.
--
--@CONTEXT UML!Class
--@RETURN String
--END DOC
helper context UML!Class def: getMergingTypedTableName(): String =
	'MERGE_' + self.getSubClassesName('_');


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el nombre del UDT que genera la clase de entrada.
--
--@CONTEXT UML!Class
--@RETURN String
--END DOC
helper context UML!Class def: getUDTName(): String =
	self.name;


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el nombre del UDT que genera el tipo de dato de entrada.
--
--@CONTEXT UML!DataType
--@RETURN String
--END DOC
helper context UML!DataType def: getUDTName(): String =
	self.name;


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el nombre del UDT de 'merging' 
--que genera la clase de entrada.
--
--@CONTEXT UML!Class
--@RETURN String
--END DOC
helper context UML!Class def: getMergingUDTName(): String =
	'MERGE_' + self.getSubClassesName('_');


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el nombre de la vista asociada a la clase de entrada.
--
--@CONTEXT UML!Class
--@RETURN String
--END DOC
helper context UML!Class def: getMergingViewName(): String =
	'GET ALL ' + self.name;

--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el nombre de la propiedad nula de entrada.
--
--@CONTEXT UML!Property
--@RETURN String
--END DOC
helper context UML!Property def: getNullPropertyName(): String =
	self.name;


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el nombre de la propiedad no nula de entrada.
--
--@CONTEXT UML!Property
--@RETURN String
--END DOC
helper context UML!Property def: getNotNullPropertyName(): String =
	self.name;


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el nombre de la referencia a la propiedad de entrada.
--
--@CONTEXT UML!Property
--@RETURN String
--END DOC
helper context UML!Property def: getAttributeREFName(): String =
	if (self.type.oclIsUndefined()) then
		OclUndefined
	else
		'Ref_' + self.type.name
	endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el nombre de la clave primaria asociada a
--la clase de entrada.
--
--@CONTEXT UML!Class
--@RETURN String
--END DOC
helper context UML!Class def: getPrimaryKeyName(pkList: Set(UML!Property)): String =
	'PK_' + self.getKeyName(pkList.asSequence());


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el nombre de la clave alternativa asociada a
--la clase de entrada.
--
--@CONTEXT UML!Class
--@RETURN String
--END DOC
helper context UML!Class def: getAlternativeKeyName(
		pkList : Set(UML!Property)): String =
		
	'AK_' + self.getKeyName(pkList.asSequence());


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el nombre del atributo discriminante asociada a
--la clase de entrada.
--
--@CONTEXT UML!Class
--@RETURN String
--END DOC
helper context UML!Class def: getDiscriminantAttributeName(): String =
	'type_of_' + self.name;


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el nombre de la restricción CHECK asociada a
--la clase de entrada.
--
--@CONTEXT UML!Class
--@RETURN String
--END DOC
helper context UML!Class def: getOneTableDiscriminantCheckName(): String =
	'Check_Discriminant_' + self.getDiscriminantAttributeName();


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el nombre de la restricción CHECK asociada a
--las relaciones de una subclase cuya jerarquía tiene que mapearse a una única
--tabla (su clase padre tiene la anotación de jerarquía a una tabla).
--
--@CONTEXT UML!Class
--@INPUT UML!Property
--@RETURN String
--END DOC
helper context UML!Class def: getOneTableChildMemberEndCheckName(
		prop : UML!Property): String =
			
	'Check_' + self.getSuperClass().name + '_' + prop.name;


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el nombre del tipo de la propiedad de entrada
--multivaluada que da lugar a una referencia.
--
--@CONTEXT UML!Property
--@RETURN String
--END DOC
helper context UML!Property def: getMultivaluedAttributeREFTypeName(): String =
	if ((self.getMultivaluedAttributeSize() = 1) or self.isVarSizeMemberEnd()) then
		self.getAttributeREFName()
	else
		self.getAttributeREFName() + '_' + self.getMultivaluedAttributeSize().toString()
	endif;
	

--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el nombre del tipo de la propiedad de entrada
--multivaluada que da lugar a un ARRAY o a un MULTISET.
--
--@CONTEXT UML!Property
--@RETURN String
--END DOC
helper context UML!Property def: getMultivaluedAttributeTypeName(): String =
	self.type.name;


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve la tabla tipada asociada a la clase de entrada.
--Si ésta no genera tabla tipada devuelve 'OclUndefined'.
--
--@CONTEXT UML!Class
--@RETURN SQL2003!TypedTable
--END DOC
helper context UML!Class def : getMergingTypedTable() : SQL2003!TypedTable =
	if (self.generatesMergingTypedTable()) then
		thisModule.resolveTemp(self, 'tt_merge')
	else
		OclUndefined
	endif;
 	

--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve los nombres de las tablas tipadas de las subclases de
--la clase de entrada.
--
--@CONTEXT UML!Class
--@RETURN String
--@LIBRARIES UML
--END DOC
helper context UML!Class def : getLeafSubClassesTypedTablesName() : String = 
	let tts : Sequence(UML!Class) = self.getLeafSubClasses().asSequence()
	in
		tts->iterate(c; names : String = '' |
			if (c = tts.last()) then 
				names + thisModule.resolveTemp(c, 'tt').name
			else		
			  	names + thisModule.resolveTemp(c, 'tt').name + ', ' 
			endif
		);


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve las tablas tipadas asociadas a las subclases de
--la clase de entrada.
--
--@CONTEXT UML!Class
--@RETURN Set(SQL2003!TypedTable)
--@LIBRARIES UML
--END DOC
helper context UML!Class def : getLeafSubClassesTypedTables() : 
		Set(SQL2003!TypedTable) =
	
	self.getLeafSubClasses()->
		iterate(c; tables : Set(SQL2003!TypedTable) = Set{} |
	  		tables->union(thisModule.resolveTemp(c, 'tt')));


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el tipo del atributo multivaluado de entrada con tamaño fijo.
--
--@CONTEXT UML!Property
--@RETURN SQL2003!ARRAY
--END DOC
helper context UML!Property def : getFixedSizeMultivaluedAttributeType() : 
		SQL2003!ARRAY =
			
	if (self.isComposition()) then
		self.getGeneratedCompositeMemberEndType()
	else
		self.getGeneratedMemberEndREFType()
	endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el tipo del atributo multivaluado de entrada con tamaño
--variable.
--
--@CONTEXT UML!Property
--@RETURN SQL2003!MULTISET
--END DOC
helper context UML!Property def : getVarSizeMultivaluedAttributeType() : 
		SQL2003!MULTISET =
			
	if (self.isComposition()) then
		self.getGeneratedCompositeMemberEndType()
	else
		self.getGeneratedMemberEndREFType()
	endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve la clase a la que pertenece el atributo de tipo referencia
--al que mapea la propiedad de entrada, que es un extremo de una asociación.
--Si el otro extremo de la asociación es una clase que pertenece a una jerarquía
--que se mapea a una única clase, la referencia apunta a la clase padre, no a
--la clase hija.
--
--@CONTEXT UML!Property
--@RETURN UML!Class
--@LIBRARIES UML
--END DOC
helper context UML!Property def : getAttributeREFClass() : UML!Class =
	--Almacena la clase UML asociada al otro extremo de la asociación
	let opposite_type : UML!Class = self.getOppositeAssociation().type
	in
		if (opposite_type.oclIsUndefined()) then
			opposite_type
		else
			if (opposite_type.isChildOfClassToOneTable()) then
				opposite_type.getFirstSuperClass()
			else
				opposite_type
			endif
		endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el ARRAY de salida cuyo tipo de sus elementos 
--será supertipo del tipo de los elementos del ARRAY de salida
--asociado a la propiedad multivaluada de entrada.
--
--En UML hay herencia múltiple pero en SQL:2003 sólo hay herencia simple.
--Además, en el modelo SQL2003 no puede haber declarados
--dos tipos ARRAY del mismo tipo, excepto que varíen en número de elementos.
--
--El metamodelo de SQL2003 dice que una colección C2 es subtipo de otra C1
--si C1 y C2 son del mismo tipo de colección (en este caso ARRAY) y el tipo
--de los elementos de C2 es subtipo del tipo de los elementos de C1.
--
--@CONTEXT UML!Property
--@RETURN SQL2003!ARRAY
--@LIBRARIES UML
--END DOC
helper context UML!Property def : getARRAYWithMAElemsSuperType() : SQL2003!ARRAY =
	if (self.isFixedSizeMultivaluedAttribute()) then
	
		--La propiedad va a dar lugar a un ARRAY en SQL2003.
		--Su tipo solamente puede ser DataType, porque los tipos
		--primitivos no admiten herencia
		if (self.type.oclIsTypeOf(UML!DataType) and 
			self.type.hasSuperDataType()) then
		
			--Obtiene el supertipo del tipo de los elementos
			let superType : UML!DataType = self.type.getFirstSuperDataType()
			in
				--Busca un atributo multivaluado cuyo tipo sea el supertipo
				--y que vaya a generar un ARRAY en SQL2003
				let superTypeProp : UML!Property =
					self.getFixedSizePropertyWithMAElemsSuperType(superType)
				in
					if (not superTypeProp.oclIsUndefined()) then
						thisModule.resolveTemp(superTypeProp, 'array')
					else
						OclUndefined
					endif
		else
			OclUndefined
		endif
	else
		OclUndefined
	endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el MULTISET de salida cuyo tipo de sus elementos 
--será supertipo del tipo de los elementos del MULTISET de salida
--asociado a la propiedad multivaluada de entrada.
--
--En UML hay herencia múltiple pero en SQL:2003 sólo hay herencia simple.
--Además, en el modelo SQL2003 no puede haber declarados
--dos tipos MULTISET del mismo tipo.
--
--El metamodelo de SQL2003 dice que una colección C2 es subtipo de otra C1
--si C1 y C2 son del mismo tipo de colección (en este caso MULTISET) y el tipo
--de los elementos de C2 es subtipo del tipo de los elementos de C1.
--
--@CONTEXT UML!Property
--@RETURN SQL2003!MULTISET
--@LIBRARIES UML
--END DOC
helper context UML!Property def : getMULTISETWithMAElemsSuperType() :
		SQL2003!MULTISET =
			
	if (self.isVarSizeMultivaluedAttribute()) then
	
		--La propiedad va a dar lugar a un MULTISET en SQL2003.
		--Su tipo solamente puede ser DataType, porque los tipos
		--primitivos no admiten herencia
		if (self.type.oclIsTypeOf(UML!DataType) and 
			self.type.hasSuperDataType()) then
		
			--Obtiene el supertipo del tipo de los elementos
			let superType : UML!DataType = self.type.getFirstSuperDataType()
			in
				--Busca un atributo multivaluado cuyo tipo sea el supertipo
				--y que vaya a generar un MULTISET en SQL2003
				let superTypeProp : UML!Property =
					self.getVarSizePropertyWithMAElemsSuperType(superType)
				in
					if (not superTypeProp.oclIsUndefined()) then
						thisModule.resolveTemp(superTypeProp, 'multiset')
					else
						OclUndefined
					endif
		else
			OclUndefined
		endif
	else
		OclUndefined
	endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper indica si el atributo de entrada pertenece a una clase y
--tiene un tipo de dato válido (el tipo no es una clase).
--
--@CONTEXT UML!Property
--@RETURN Boolean
--END DOC
helper context UML!Property def : isValidClassAttribute() : Boolean =
	(self.refImmediateComposite().oclIsTypeOf(UML!Class))
	and
	(
		(self.type.oclIsTypeOf(UML!PrimitiveType)) or
		(self.type.oclIsTypeOf(UML!DataType))
	);


--BEGIN DOC
--#DESCRIPTION
--Este helper indica si el atributo de entrada es clave primaria.
--Tiene que tener anotación de clave primaria, pertenecer a una clase y 
--no ser ni clave alternativa, ni atributo derivado ni multivaluado.
--
--@CONTEXT UML!Property
--@RETURN Boolean
--@LIBRARIES UML, UML2SQL2003_AMW
--END DOC
helper context UML!Property def : isPrimaryKeyAttribute() : Boolean =
	(self.refImmediateComposite().oclIsTypeOf(UML!Class)) and
	(self.type.oclIsTypeOf(UML!PrimitiveType)) and
	(self.hasPrimaryKeyAnnotation()) and
	(not self.hasAlternativeKeyAnnotation()) and
	(not self.hasDerivedAttributeAnnotation()) and
	(not self.hasMultiMaxCardinality());


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve un conjunto de atributos que son claves primarias
--de la clase de entrada.
--
--@CONTEXT UML!Class
--@RETURN Set(UML!Property)
--END DOC
helper context UML!Class def : getPrimaryKeyAttributes() : Set(UML!Property) =
	self.ownedAttribute->select(prop | prop.isPrimaryKeyAttribute()).asSet();


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve un conjunto de atributos que son claves primarias
--de una clase ancestro de la clase de entrada.
--
--@CONTEXT UML!Class
--@RETURN Set(UML!Property)
--@LIBRARIES UML
--END DOC
helper context UML!Class def : getSuperPrimaryKeyAttributes() : Set(UML!Property) =
	if (self.hasSuperClass()) then
		--CASO RECURSIVO: Sigue buscando PKs en los ancentros
		self.getFirstSuperClass().getPrimaryKeyAttributes()->
			union(self.getFirstSuperClass().getSuperPrimaryKeyAttributes())
	else
		--CASO BASE: para de buscar PK porque ha llegado a la raíz
		Set{}
	endif;

	
--BEGIN DOC
--#DESCRIPTION
--Este helper indica si la clase de entrada tiene atributos declarados
--como claves primarias.
--
--@CONTEXT UML!Class
--@RETURN Boolean
--END DOC
helper context UML!Class def : hasPrimaryKey() : Boolean =
	self.getPrimaryKeyAttributes().notEmpty();


--BEGIN DOC
--#DESCRIPTION
--Este helper indica si alguna clase ancestro de la clase de entrada 
--tiene atributos declarados como claves primarias.
--
--@CONTEXT UML!Class
--@RETURN Boolean
--@LIBRARIES UML
--END DOC
helper context UML!Class def : hasSuperPrimaryKey() : Boolean =
	if (self.hasSuperClass()) then
		if (self.getFirstSuperClass().hasPrimaryKey())then
			true
		else
			self.getFirstSuperClass().hasSuperPrimaryKey()		
		endif
	else
		false
	endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper indica si el atributo de entrada es clave alternativa.
--Tiene que tener anotación de clave alternativa, pertenecer a una clase y 
--no ser ni clave primaria, ni atributo derivado ni multivaluado.
--
--@CONTEXT UML!Property
--@RETURN Boolean
--@LIBRARIES UML, UML2SQL2003_AMW
--END DOC
helper context UML!Property def : isAlternativeKeyAttribute() : Boolean =
	(self.refImmediateComposite().oclIsTypeOf(UML!Class)) and
	(self.type.oclIsTypeOf(UML!PrimitiveType)) and
	(not self.hasPrimaryKeyAnnotation()) and
	(self.hasAlternativeKeyAnnotation()) and
	(not self.hasDerivedAttributeAnnotation()) and
	(not self.hasMultiMaxCardinality());


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve un conjunto de atributos que son claves alternativas
--de la clase de entrada.
--
--@CONTEXT UML!Class
--@RETURN Set(UML!Property)
--END DOC
helper context UML!Class def : getAlternativeKeyAttributes() : Set(UML!Property) =
	self.ownedAttribute->select(prop | prop.isAlternativeKeyAttribute()).asSet();


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve un conjunto de atributos que son claves alternativas
--de una clase ancestro de la clase de entrada.
--
--@CONTEXT UML!Class
--@RETURN Set(UML!Property)
--@LIBRARIES UML
--END DOC
helper context UML!Class def : getSuperAlternativeKeyAttributes() : 
		Set(UML!Property) =
		
	if (self.hasSuperClass()) then
		--CASO RECURSIVO: Sigue buscando AKs en los ancentros
		self.getFirstSuperClass().getAlternativeKeyAttributes()->
			union(self.getFirstSuperClass().getSuperAlternativeKeyAttributes())
	else
		--CASO BASE: para de buscar AK porque ha llegado a la raíz
		Set{}
	endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper indica si la clase de entrada tiene atributos declarados
--como claves alternativas.
--
--@CONTEXT UML!Class
--@RETURN Boolean
--END DOC
helper context UML!Class def : hasAlternativeKey() : Boolean =
	self.getAlternativeKeyAttributes().notEmpty();


--BEGIN DOC
--#DESCRIPTION
--Este helper indica si alguna clase ancestro de la clase de entrada 
--tiene atributos declarados como claves alternativas.
--
--@CONTEXT UML!Class
--@RETURN Boolean
--@LIBRARIES UML
--END DOC
helper context UML!Class def : hasSuperAlternativeKey() : Boolean =
	if (self.hasSuperClass()) then
		if (self.getFirstSuperClass().hasAlternativeKey()) then
			true
		else
			self.getFirstSuperClass().hasSuperAlternativeKey()		
		endif
	else
		false
	endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve una cadena de texto con los nombres de los atributos
--de la colección de entrada. Estos atributos deberían ser las claves 
--primarias o alternativas de la clase desde donde se llama a este helper.
--
--@CONTEXT UML!Class
--@INPUT Sequence(UML!Property)
--@RETURN String
--#PRECONDITION La colección de atributos de entrada son PKs o AKs.
--END DOC
helper context UML!Class def : getKeyName(colAtt : Sequence(UML!Property)): String =
	colAtt->iterate(prop; names : String = '' |
			if (prop = colAtt.last()) then 
				names + prop.name
			else		
			  	names + prop.name + '_' 
			endif
	);


--BEGIN DOC
--#DESCRIPTION
--Este helper indica si el atributo de entrada es derivado.
--Tiene que tener anotación de atributo derivado, pertenecer a una clase y 
--no ser ni clave primaria, ni clave alternativa, ni atributo multivaluado.
--
--@CONTEXT UML!Property
--@RETURN Boolean
--@LIBRARIES UML, UML2SQL2003_AMW
--END DOC
helper context UML!Property def : isDerivedAttribute() : Boolean =
	(self.refImmediateComposite().oclIsTypeOf(UML!Class)) and
	(self.type.oclIsTypeOf(UML!PrimitiveType)) and
	(not self.hasPrimaryKeyAnnotation()) and
	(not self.hasAlternativeKeyAnnotation()) and
	(self.hasDerivedAttributeAnnotation()) and
	(not self.hasMultiMaxCardinality());


--BEGIN DOC
--#DESCRIPTION
--Este helper indica si el atributo de entrada es multivaluado.
--Tiene que tener cardinalidad mayor que 1, pertenecer a una clase y 
--no ser ni clave primaria, ni clave alternativa, ni atributo derivado.
--
--@CONTEXT UML!Property
--@RETURN Boolean
--@LIBRARIES UML, UML2SQL2003_AMW
--END DOC
helper context UML!Property def : isMultivaluedAttribute() : Boolean =
	(self.isValidClassAttribute()) and
	(not self.hasPrimaryKeyAnnotation()) and
	(not self.hasAlternativeKeyAnnotation()) and
	(not self.hasDerivedAttributeAnnotation()) and
	(self.hasMultiMaxCardinality());


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el tamaño de un atributo multivaluado de tamaño fijo
--del modelo de entrada.
--Si el atributo tiene anotación de tamaño devuelve su valor,
--y si no la tiene devuelve el valor por defecto.
--Si no es
--
--@CONTEXT UML!Property
--@RETURN Integer
--@LIBRARIES UML, UML2SQL2003_helper, UML2SQL2003_AMW
--END DOC
helper context UML!Property def : getMultivaluedAttributeSize() : Integer =
	if (self.isMultivaluedAttribute()) then
		if (self.hasSizeAnnotation()) then
			self.getSizeAnnotation()
		else
			if (self.upperValue.oclIsUndefined()) then
				thisModule.DEFAULT_ARRAY_SIZE()
			else
				if (self.upperValue.value > 0) then
					self.upperValue.value
				else
					thisModule.DEFAULT_ARRAY_SIZE()
				endif
			endif
		endif
	else
		if (self.isFixedSizeMemberEnd() or self.isVarSizeMemberEnd()) then
			if (self.upperValue.oclIsUndefined()) then
				thisModule.DEFAULT_ARRAY_SIZE()
			else
				if (self.upperValue.value > 0) then
					self.upperValue.value
				else
					thisModule.DEFAULT_ARRAY_SIZE()
				endif
			endif
		else
			1
		endif
	endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper indica si el atributo de entrada es no nulo. No puede ser ni
--primary key ni derivado.
--
--@CONTEXT UML!Property
--@RETURN Boolean
--@LIBRARIES UML2SQL2003_AMW, UML
--END DOC
helper context UML!Property def : isNotNullAttribute() : Boolean =
	if (self.isValidClassAttribute()) then
		self.hasNotNullAnnotation() and
		(not self.hasDerivedAttributeAnnotation()) and
		(not self.hasPrimaryKeyAnnotation())
	else
		false
	endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper indica si el atributo de entrada es multivaluado
--y tiene un límite máximo de valores.
--Comprueba primero que tiene anotación de multivaluado y con tamaño limitado.
--Si no la tiene comprueba que su cardinalidad máxima sea mayor de 1.
--
--@CONTEXT UML!Property
--@RETURN Boolean
--@LIBRARIES UML2SQL2003_AMW, UML
--END DOC
helper context UML!Property def : isFixedSizeMultivaluedAttribute() : Boolean =
	if (self.isMultivaluedAttribute()) then
		if (self.hasMultivaluedAttributeAnnotation()) then
			self.isMapMultivaluedAttributeToArray()
		else
			self.hasFixedSizeMultiMaxCardinality()
		endif
	else
		false
	endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper indica si el atributo de entrada es multivaluado
--y no tiene un límite máximo de valores.
--Comprueba primero que tiene anotación de multivaluado y sin tamaño limitado.
--Si no la tiene comprueba que su cardinalidad máxima sea igual a -1.
--
--@CONTEXT UML!Property
--@RETURN Boolean
--@LIBRARIES UML2SQL2003_AMW, UML
--END DOC
helper context UML!Property def : isVarSizeMultivaluedAttribute() : Boolean =
	if (self.isMultivaluedAttribute()) then
		if (self.hasMultivaluedAttributeAnnotation()) then
			self.isMapMultivaluedAttributeToMultiset()
		else
			self.hasVarSizeMultiMaxCardinality()
		endif
	else
		false
	endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve la propiedad multivaluada cuyo tipo es
--supertipo del tipo de dato de entrada, perteneciente a la propiedad
--de entrada. Y además que genere un ARRAY de SQL2003.
--
--@CONTEXT UML!Property
--@INPUT UML!DataType
--@RETURN UML!Property
--@LIBRARIES UML, UML_constants, UML2SQL2003_AMW
--END DOC
helper context UML!Property def : getFixedSizePropertyWithMAElemsSuperType(
		superDT : UML!DataType) : UML!Property =
			
	let col : Sequence(UML!Property) =
		thisModule.PROPERTIES()->asSequence()->
			select(prop | prop <> self and
				prop.isFixedSizeMultivaluedAttribute()
			)->select(propMA | (propMA.type = superDT))
	in
		if (col.size() > 0) then
			col->first()
		else
			OclUndefined
		endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve la propiedad multivaluada cuyo tipo es
--supertipo del tipo de dato de entrada, perteneciente a la propiedad
--de entrada. Y además que genere un MULTISET de SQL2003.
--
--@CONTEXT UML!Property
--@INPUT UML!DataType
--@RETURN UML!Property
--@LIBRARIES UML, UML_constants, UML2SQL2003_AMW
--END DOC
helper context UML!Property def : getVarSizePropertyWithMAElemsSuperType(
		superDT : UML!DataType) : UML!Property =
			
	let col : Sequence(UML!Property) =
		thisModule.PROPERTIES()->asSequence()->
			select(prop | prop <> self and
				prop.isVarSizeMultivaluedAttribute()
			)->select(propMA | (propMA.type = superDT))
	in
		if (col.size() > 0) then
			col->first()
		else
			OclUndefined
		endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve la consulta de la vista asociada a la clase de entrada.
--Incluye en la consulta todas las tablas tipadas de sus subclases hoja y si es
--solapada también la sublcase 'merging'.
--
--@CONTEXT UML!Class
--@RETURN String
--@LIBRARIES UML
--#PRECONDITION La clase de entrada tiene alguna subclase.
--END DOC
helper context UML!Class def : getViewQuery() : String =
	let cadena : String = 
		'SELECT * FROM ' + self.getLeafSubClassesTypedTablesName()
	in
		if (self.isOverlappingHierarchy() and (not self.hasOneSubClass())) then
			cadena = cadena + self.getMergingTypedTableName()
		else
			cadena
		endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve una cadena con el nombre de las tablas tipadas de las
--subclases de la clase de entrada.
--
--@CONTEXT UML!Class
--@RETURN String
--@LIBRARIES UML
--#PRECONDITION La clase tiene al menos una subclase
--END DOC
helper context UML!Class def : getSubTablesName() : String = 
	self.getSubClasses()->
		iterate(c; tables : String = '' |
			tables + ', '+ thisModule.resolveTemp(c, 'tt').name);


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve una cadena con la expresión de la restricción CHECK
--asociada a la tabla tipada de la clase de entrada.
--
--@CONTEXT UML!Class
--@RETURN String
--@LIBRARIES UML, UML_constants
--#PRECONDITION La clase tiene al menos una subclase y una anotación para mapear
--la jerarquía a una única tabla.
--END DOC
helper context UML!Class def : getOneTableDiscriminantCheckExpression() : String =
	let discriminant : String = thisModule.resolveTemp(self,'discriminant')
	in
		let exp : String = 'CHECK (' + discriminant.name + ' IN ('
		in
			let subexpPartial : String = exp + '\'' + self.name + '\', \'' +
				self.getAllSubClassesName('\', \'')
			in
				let subexpTotal : String = exp + self.getAllSubClassesName('\', \'')
				in
					if (
						self.isPartialHierarchy() or
						(not self.isTotalHierarchy() and (not self.isAbstract))
					) then
						if ((self.isOverlappingHierarchy()) and
							(not self.hasOneSubClass())) then
						
							--El nombre de la superclase y 
							--otro nombre asociado a la tabla
							--de solapados de las subclases 
							--se incluye en el discriminante
							subexpPartial + 
							'\', \'' + thisModule.DISCRIMINANT_OVERLAPPING() + '\'))'
						else
							--El nombre de la superclase 
							--se incluye en el discriminante
							subexpPartial + '\'))'
						endif
					else
						if ((self.isOverlappingHierarchy()) and
							(not self.hasOneSubClass())) then
						
							--El nombre de la superclase y 
							--otro nombre asociado a la tabla
							--de solapados de las subclases 
							--se incluye en el discriminante
							subexpTotal + 
							'\', \'' + thisModule.DISCRIMINANT_OVERLAPPING() + '\'))'
						else
							--El nombre de la superclase 
							--se incluye en el discriminante
							subexpTotal + '\'))'
						endif
					endif;
	

--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve una cadena con la expresión de la restricción CHECK
--asociada a las relaciones 1..x o N..x de una subclase cuya jerarquía tiene que 
--mapearse a una única tabla (su clase padre tiene la anotación de jerarquía a 
--una tabla).
--
--@CONTEXT UML!Class
--@INPUT UML!Property
--@RETURN String
--#PRECONDITION La clase tiene una superclase con una anotación para mapear
--la jerarquía a una única tabla.
--END DOC
helper context UML!Class def : getOneTableChildMemberEndNotNullCheckExpression(
		prop : UML!Property) : String =
	
	let discriminant : UML!Attribute = thisModule.resolveTemp(
		self.getSuperClass(), 'discriminant')
	in
		'CHECK ((' +
			'NOT (' + discriminant.name + ' LIKE \'' + self.name + '\')' +
			') and (' +
			prop.name + ' IS NULL))' + 
		' or ((' + 
			discriminant.name + ' LIKE \'' + self.name + '\'' +
			') and (' +
			prop.name + ' IS NOT NULL))';


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve una cadena con la expresión de la restricción CHECK
--asociada a las relaciones 0..x de una subclase cuya jerarquía tiene que mapearse a 
--una única tabla (su clase padre tiene la anotación de jerarquía a una tabla).
--
--@CONTEXT UML!Class
--@INPUT UML!Property
--@RETURN String
--#PRECONDITION La clase tiene una superclase con una anotación para mapear
--la jerarquía a una única tabla.
--END DOC
helper context UML!Class def : getOneTableChildMemberEndNullCheckExpression(
		prop : UML!Property) : String =
	
	let discriminant : UML!Attribute = thisModule.resolveTemp(
		self.getSuperClass(), 'discriminant')
	in
		'CHECK ((' +
			'NOT (' + discriminant.name + ' LIKE \'' + self.name + '\')' +
			') and (' +
			prop.name + ' IS NULL))' + 
		' or ((' + 
			discriminant.name + ' LIKE \'' + self.name + '\'' +
			') and ((' +
					prop.name + ' IS NULL)' +
				' or (' +
					prop.name + ' IS NOT NULL)' +
				'))';


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve las propiedades de una clase que son clave primaria o
--alternativa en el modelo de entrada.
--
--@CONTEXT AMW!Annotation
--@RETURN Set(UML!Property)
--@LIBRARIES UML
--END DOC
helper context AMW!Annotation def : getKeyAttributes() : Set(UML!Property) =
	self.annotatedModelElement->asSequence()->
		iterate(annotated; attributes : Set(UML!Property) = Set{} |
			attributes->union(Set{annotated.getAssociatedProperty()}));


--BEGIN DOC
--#DESCRIPTION
--Este helper indica si el tipo de una propiedad multivaluada de una clase
--ha sido mapeado a un elemento del modelo de salida.
--
--@CONTEXT UML!Property
--@RETURN Boolean
--@LIBRARIES UML
--END DOC
helper context UML!Property def : isGeneratedMultivaluedType() : Boolean =
	let subseq : Sequence(UML!Property) = 
		thisModule.CLASS_MULTIVALUED_PROPERTIES()->subSequence(1,
			thisModule.CLASS_MULTIVALUED_PROPERTIES()->indexOf(self))
	in
		subseq->select(prop | self.isSameMultivaluedAttributeType(prop))->size()>1;


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el tipo de una propiedad multivaluada de clase
--que ha generado ya el tipo de la propiedad multivaluada de clase de entrada.
--
--@CONTEXT UML!Property
--@RETURN SQL2003!CollectionType
--END DOC
helper context UML!Property def : getGeneratedMultivaluedType() : 
		SQL2003!CollectionType =
			
	let prop : UML!Property = thisModule.CLASS_MULTIVALUED_PROPERTIES()->
		any(prop | prop.isSameMultivaluedAttributeType(self))
	in
		if (prop.isFixedSizeMultivaluedAttribute()) then
			thisModule.resolveTemp(prop, 'array')
		else
			if (prop.isVarSizeMultivaluedAttribute()) then
				thisModule.resolveTemp(prop, 'multiset')
			else
				OclUndefined
			endif
		endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el tipo de una propiedad asociada a un extremo de una
--asociación 0..1 o 1..1, que es una referencia a una clase del modelo de entrada.
--
--@CONTEXT UML!Property
--@RETURN SQL2003!ReferenceType
--END DOC
helper context UML!Property def : getGeneratedAttributeREFType() : 
		SQL2003!ReferenceType =
			
	let prop : UML!Property = thisModule.MEMBERS_END_2_CLASS_REF()->
		union(thisModule.MEMBERS_END_2_CLASS_REF_COLLECTION())->
			any(prop | prop.isSameAttributeREFType(self))
	in
		thisModule.generateAttributeREF(prop);


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el tipo de una propiedad asociada a un extremo de una
--composición, que es una colección sobre una clase del modelo de entrada,
--y que ya ha sido generado previamente por otro extremo.
--
--@CONTEXT UML!Property
--@RETURN SQL2003!CollectionType
--@LIBRARIES UML
--END DOC
helper context UML!Property def : getGeneratedCompositeMemberEndType() : 
		SQL2003!CollectionType =

	let prop : UML!Property = thisModule.MEMBERS_END_2_CLASS_COLLECTION()->
		any(prop | prop.isSameCompositeMemberEndType(self))
	in
		if (prop.isFixedSizeMemberEnd()) then
			thisModule.generateARRAY(prop)
		else
			if (prop.isVarSizeMemberEnd()) then
				thisModule.generateMULTISET(prop)
			else
				OclUndefined
			endif
		endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve el tipo de una propiedad asociada a un extremo de
--una asociación que no es composición ni tiene cardinalidad máxima 1,
--El tipo es una colección de referencias a una clase del modelo de entrada,
--y que ya ha sido generado previamente por otro extremo.
--
--@CONTEXT UML!Property
--@RETURN SQL2003!CollectionType
--@LIBRARIES UML
--END DOC
helper context UML!Property def : getGeneratedMemberEndREFType() : 
		SQL2003!CollectionType =

	let prop : UML!Property = thisModule.MEMBERS_END_2_CLASS_REF_COLLECTION()->
		any(prop | prop.isSameCompositeMemberEndType(self))
	in
		if (prop.isFixedSizeMemberEnd()) then
			thisModule.generateARRAYREF(prop)
		else
			if (prop.isVarSizeMemberEnd()) then
				thisModule.generateMULTISETREF(prop)
			else
				OclUndefined
			endif
		endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper devuelve la clase a la que apunta un extremo de una asociación.
--Si la clase es abstracta se devuelve su primer ancestro no abstracto.
--
--@CONTEXT UML!Property
--@RETURN UML!Class
--END DOC
helper context UML!Property def : getMemberEndClass() : UML!Class =
	if (self.type.hasSuperClass()) then
		if (self.type.getSuperClass().isMapClassToOneTable()) then
			self.type.getSuperClass()
		else
			self.type
		endif
	else
		self.type
	endif;


--BEGIN DOC
--#DESCRIPTION
--Este helper indica si una propiedad forma parte de una clase abstracta que tiene
--jerarquia y que se va a mapear a una tabla. 
--
--@CONTEXT UML!Property
--@RETURN UML!Class
--END DOC
helper context UML!Property def : isAbstractClassWithOneTableAnnotation() : Boolean =
	if (self.isAbstractClassProperty()) then
		self->refImmediateComposite().isMapClassToOneTable()
	else
		false
	endif;