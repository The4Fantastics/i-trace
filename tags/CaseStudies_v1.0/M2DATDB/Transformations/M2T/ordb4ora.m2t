/**
 * transformation codigo
 *
 *
 */

texttransformation codigo (in eco:"http:///ORDB4ORA.ecore") {
   eco.Model::main(){
     println("--> Time Start: " + time())
     var nombre:String
     
     
     if (self.Name.size()=0)
     	nombre="codigo_ORDB4ORA.sql"
     else
     	nombre=self.Name + "_ORDB4ORA.sql"
     file (nombre)
                   
     //genera codigo para los Structured Type
     self.datatype->forEach(s:eco.StructuredType)
     {
       s.generateStructured()
       println("")
     }
     
    //generar codigo para las Referencias
 	self.datatype->forEach(r:eco.ReferenceType){
 	   println("CREATE OR REPLACE TYPE " + r.Name + " AS OBJECT (ref  REF " + r.Type.Name + ");")
 	   println("/")
 	}   
     
    //genera codigo para los Varray
     self.datatype->forEach(v:eco.Varray) {
        var tipo:String
        if (v.Type.oclIsKindOf(eco.BasicDataType))
				tipo=v.Type.Descriptor
         else {
	         	tipo=v.Type.Name
         }
       println("CREATE OR REPLACE TYPE " + v.Name + " AS VARRAY(" + v.NumElements + ") OF " + tipo + ";")
       println("/")
     }
    
    //genera codigo para los Nested Table
     self.datatype->forEach(n:eco.NestedTableType) {
       var tipo:String
		if (n.Type.oclIsKindOf(eco.BasicDataType))
         		  tipo=n.Type.Descriptor
       else {
	         	tipo=n.Type.Name
       }
        println("CREATE OR REPLACE TYPE " + n.Name + " AS TABLE OF " + tipo + ";")
        println("/")
     }
     
     //genera codigo para las tablas externas
     self.table->forEach(t:eco.Table) {
       if(t.oclIsTypeOf(eco.Table))
       	t.generateTable()
     }
	 
	 self.package->forEach(p:eco.Package)
	 {
	   p.generatePackage()
	   println("\n")
	 }
	 self.operation->forEach(p:eco.Procedure)
	 {
	   if(p.package = null)
	   	{
	   	  print("CREATE OR REPLACE ")
	   	 p.generateProcedure()
	   	println("")
	   	}
	 }
	 
	 self.operation->forEach(f:eco.Function)
	 {
	   if(f.package = null)
	   	{
	   	  print("CREATE OR REPLACE ")
	   	  f.generateFunction()
	   	println("")
	   	}
	 }
	 
     self.table->forEach(v:eco.View)
	 {
	   v.generateView()
	   	println("")
	   	
	 } 
	  
	   println("--> Time End: " + time())	
   }
   
   //funcion que genera el codigo de un structured type
   eco.StructuredType::generateStructured() {
       var texto:String=""
       var i:Integer=0	
       if (self.supertype.Name.size()=0)
       		texto="CREATE OR REPLACE TYPE " + self.Name + " AS OBJECT"
       		else
       		texto="CREATE OR REPLACE TYPE " + self.Name + " UNDER " + self.supertype.Name
       		
       	if(self.attribute.size() == 0 and self.method.size() == 0)
       		print(texto + "()")
       	else
       	{   
       	  	println(texto + "\n(")
       	   	//añade los atributos del udt
       		self.attribute->forEach(a:eco.Attribute)
       		{ 
       		  i=i+1
       		  a.generateAttribute()
       		  if(i== self.attribute.size())
       		  	println("")
       		  else
       		  println(",")
       		}
       
       		//añade los metodos del udt
       		self.method->forEach(m:eco.Method){m.generateMethod()}
       
  	   		print(")")
       	}

  	   if(self.is_final)
       		print(" FINAL")		
       else
       		print(" NOT FINAL")
       		
       if(self.is_instantiable)
       		println(" INSTANTIABLE;")
       		
       else
       		println(" NOT INSTANTIABLE;")
       println("/")
      
       //genera las tablas tipadas
       self.typed->forEach(t:eco.TypedTable){
         println("")
         var restrictions:List = t.restriction->select(r:eco.Restriction|r.oclIsTypeOf(eco.PrimaryKey) or r.oclIsTypeOf(eco.ForeignKey) or r.oclIsTypeOf(eco.Check) or r.oclIsTypeOf(eco.Unique) or r.oclIsTypeOf(eco.NotNull))

         if(restrictions.size() == 0)
         	print("CREATE TABLE " + t.Name + " OF " + self.Name)
         else	
         	{
         	  println("CREATE TABLE " + t.Name + " OF " + self.Name +"\n(")
         	  t.generateTypedTableBody()
         	  print("\n)")
         	}
         t.generateStoredNestedTables()
         println(";")
		 t.triggers->forEach(t:eco.Trigger)
      	 {
      	   	println("")
        	t.generateTrigger()
        	println(";")
      	 }
       }
    }
   
   //funcion que genera las Stored Nested Tables
   eco.TypedTable::generateStoredNestedTables() {
   	var n_snt:integer= self.storedNested.size();
   	self.storedNested->forEach(snt:eco.StoredNestedTable){
   		println("");
   		print("NESTED TABLE "+snt.attribute.Name+" STORE AS "+snt.Name)
   	}
   }
   
  //funcion que genera las tablas tipadas
  eco.TypedTable::generateTypedTableBody() {
     var j:integer=0
     var rCount:integer = self.restriction->select(r:eco.Restriction|r.oclIsTypeOf(eco.PrimaryKey) or r.oclIsTypeOf(eco.ForeignKey) or r.oclIsTypeOf(eco.Check) or r.oclIsTypeOf(eco.Unique) or r.oclIsTypeOf(eco.NotNull)).size()
     var texto2:String=""
     var texto:String=""
     //añado las restricciones 
     self.restriction->forEach(r:eco.PrimaryKey){
         j+=1
      	 r.attributes ->forEach(c:eco.Attribute){
         	texto2="  "+c.Name + "  PRIMARY KEY "
            print(texto2)
      	 }
          if (j < rCount)
          	 	println(",")
          texto2="" 
          
          }
       
     self.restriction->forEach(r:eco.Unique){
          j+=1
      	  r.attributes->forEach(c:eco.Attribute){
         	texto2="  "+c.Name + "  UNIQUE "
           	print(texto2)
      	 }
          if (j < rCount)
          	 	println(",")
          texto2=""         
    }
     
    self.restriction->forEach(r:eco.ForeignKey){
          j+=1
      	  texto2 = ""
      	  r.attributes->forEach(c:eco.Attribute){
           texto2+="  "+c.Name + "  FOREIGN KEY "
           print(texto2)
           texto2=""
      	 }
      	  print("  REFERENCES " + r.reference.Name + " ONDELETE " + r.OnDelete) //diferencias atributos origen y destino
          if (j < rCount)
          	 	println(",")
          texto2="" 
    }
    
      self.restriction->forEach(r:eco.Check){
          j+=1
          print("  CHECK " + r.Name + " (" + r.Condition+ ")")
          if (j < rCount)
          	 	println(",")
          texto2="" 
      	 }
      	 
      self.restriction->forEach(r:eco.NotNull){
          j+=1
      	  r.attributes->forEach(c:eco.Attribute){
         	texto2="  "+c.Name + "  NOT NULL "
           	print(texto2)
      	 }
          if (j < rCount)
          	 println(",")
          texto2="" 
      	 } 
  	}
  	
  	
  	//funcion que genera las tablas
  	eco.Table::generateTable() {
  	   var j:integer=0
  	   var i:integer=0
  	   var rCount:integer= self.restriction->select(r:eco.Restriction|r.oclIsTypeOf(eco.PrimaryKey) or r.oclIsTypeOf(eco.ForeignKey) or r.oclIsTypeOf(eco.Check) or r.oclIsTypeOf(eco.Unique) or r.oclIsTypeOf(eco.NotNull)).size()
       var texto2:String=""
       println("CREATE TABLE " + self.Name + "\n(")
       
       self.columns->forEach(a:eco.Column) {
       	  i=i+1
       	 a.generateAttribute()
       	 if(i == self.columns.size())
       	 	println("")
       	 	else
       	 	println(",")
       }
       //añado las restricciones 
       self.restriction->forEach(r:eco.PrimaryKey){
             j+=1
             print("  PRIMARY KEY (")
          	 var num:integer=0
          	 r.attributes->forEach(a:eco.Column){
          	   num+=1
          	   if (num < r.attributes.size())
             	  texto2=a.Name + ", "  
               else
             	  texto2=a.Name + ")"
               print(texto2)
          	 }
			if (j < rCount)
          	 	print(",")
          	 texto2=""
          	  println("")
       }
       
       self.restriction->forEach(r:eco.Unique){
              j+=1
              print("  UNIQUE (")
          	  var num:integer=0
          	  r.attributes->forEach(a:eco.Column){
          	   num+=1
          	   if (num < r.attributes.size())
             	  texto2=a.Name + ", "  
               else
             	  texto2=a.Name + ")"
               print(texto2)
               texto2=""
          	 }
        	if (j < rCount)
          	 	print(",")
          	 texto2=""
          	  println("")
      	 }
         
          self.restriction->forEach(r:eco.Check){
          	j+=1
          	print("  CHECK " + r.Name + " (" + r.Condition+ ")")
          	if (j < rCount)
          		 	print(",")
          	 	texto2=""
          	 	 println("")
      	 	}

      	  
       self.restriction->forEach(r:eco.ForeignKey){
            j+=1
             print("  FOREIGN KEY (")
          	  var num:integer=0
          	  r.attributes->forEach(a:eco.Column){
          	   num+=1
          	   if (num < r.attributes.size())
             	    texto2+=a.Name + ", "
               else
             	  texto2+=a.Name + ")"
               print(texto2)
               texto2=""
          	 }
          	 print(" REFERENCES " + r.reference.Name + " ONDELETE " + r.OnDelete) 
          	 if (j < rCount)
          	 	print(",")
          	 texto2=""
          	  println("")
       }
       self.restriction->forEach(r:eco.NotNull){
              j+=1
              print("  NOT NULL (")
          	  var num:integer=0
          	  r.attributes->forEach(a:eco.Column){
          	   num+=1
          	   if (num < r.attributes.size())
             	  texto2=a.Name + ", "  
               else
             	  texto2=a.Name + ")"
               print(texto2)
               texto2=""
          	 }
        	if (j < rCount)
          	 	print(",")
          	 texto2=""
          	  println("")
      	 }
         
      println(");\n")
      self.triggers->forEach(t:eco.Trigger)
      {
        t.generateTrigger()
        println("\n")
      }
  	}
  	
	//Generar Método de los UDT
	eco.Method::generateMethod(){
		  
     var tipo:String

	print("  MEMBER FUNCTION " + self.Name)
	
   	if(self.parameters.size()>0)
	{
	  	print(" (")
    	self.parameters ->forEach(p:eco.Parameter)
    	{
    	    if( p.Type.oclIsKindOf(eco.BasicDataType))
         		tipo= p.Type.Descriptor
            else {tipo=p.Type.Name}
    		print(" " + p.Name + " " + tipo)
 	   }
 	   print(" )")
	}
	
    if ( self.returnType.oclIsKindOf(eco.BasicDataType))
         		tipo= self.returnType.Descriptor
          else {
	         	tipo=self.returnType.Name
          }
	
	println(" RETURN " + tipo)
	
	}
	
	eco.BasicDataType::getDescriptorName():String{
      var type:String=self.Descriptor
      if(type.equals("TIMESTAMPWITHTIMEZONE")){
        	return "TIMESTAMP WITH TIME ZONE";
      }else if(type.equals("TIMESTAMPWITHOUTIMEZONE")){
        	return "TIMESTAMP WITHOUT TIME ZONE";
      }else if(type.equals("INTERVALYEARTOMONTH")){
        	return "INTERVAL YEAR TO MONTH";
      }else if(type.equals("INTERVALDAYTOSECOND")){
        	return "INTERVAL DAY TO SECOND";
      }else if(type.equals("SDO_RASTER")){
        	return "SDO_GEORASTER";
      }else if(type.equals("LONGRAW")){
        	return "LONG RAW";
      }else if(type.equals("DOUBLEPRECISION")){
        	return "DOUBLE PRECISION";
      }else if(type.equals("SYSANYDATA")){
        	return "SYS.ANYDATA";
      }else if(type.equals("SYSANYTYPE")){
        	return "SYS.ANYTYPE";
      }else if(type.equals("SYSANYDATASET")){
        	return "SYS.ANYDATASET";
      }else if(type.equals("CHARACTERVARYING")){
        	return "CHARACTER VARYING";
      }else if(type.equals("CHARVARYING")){
        	return "CHAR VARYING";
      }else if(type.equals("NCHARVARYING")){
        	return "NCHAR VARYING";
      }else if(type.equals("NATIONALCHARACTER")){
        	return "NATIONAL CHARACTER";
      }else if(type.equals("NATIONALCHAR")){
        	return "NATIONAL CHAR";
      }else if(type.equals("NATIONALCHARACTERVARYING")){
        	return "NATIONAL CHARACTERVARYING";
      }else if(type.equals("NATIONALCHARVARYING")){
        	return "NATIONAL CHARVARYING";
      }else{
          return type;
      }
    }
	
	eco.Datatype::generateType(att:eco.Attribute,level:integer):String{
		  var i:integer=0
  	      var nullable:Boolean = false
       	  var fCount:integer
          var tipo:String
          var texto:String=""
          var notNulls:List=null;

          if (self.oclIsKindOf(eco.BasicDataType))
         		{
         		  tipo=att.Type.getDescriptorName()
         		  if(att.features.size()>0)
         		  { 
         		    tipo+="("
         		    fCount+=0
         		  	att.features->forEach(f:eco.CharacterFeature)
         		  	{
         		  	  	fCount+=1
         		   		 tipo+=f.value
         		   		 if(fCount< att.features.size())
         		   		 	tipo+=","
         		  	}
         		  	att.features->forEach(f:eco.DatetimeFeature)
         		  	{
         		  	  	fCount+=1
         		   		 tipo+=f.value
         		   		 if(fCount< att.features.size())
         		   		 	tipo+=","
         		  	}
         		  	att.features->forEach(f:eco.IntervalFeature)
         		  	{
         		  	  	fCount+=1
         		   		 tipo+=f.value
         		   		 if(fCount< att.features.size())
         		   		 	tipo+=","
         		  	}
         		  	att.features->forEach(f:eco.NumberFeature)
         		  	{
         		  	  	fCount+=1
         		   		 tipo+=f.value
         		   		 if(fCount< att.features.size())
         		   		 	tipo+=","
         		  	}
         		   att.features->forEach(f:eco.RawFeature)
         		  	{
         		  	  	fCount+=1
         		   		 tipo+=f.value
         		   		 if(fCount< att.features.size())
         		   		 	tipo+=","
         		  	}
         		  	tipo+=")"
         		  }
         }
         else {
	        	if(self.oclIsTypeOf(eco.Varray))
	         	{
	         	 tipo+=self.Type.generateType(att,level+1)
	         	}
	         	else
	        		if(self.oclIsTypeOf(eco.NestedTableType)){
	        			tipo+=att.Type.Name
	        		}else		 	
	        			if(self.oclIsTypeOf(eco.ReferenceType))
	          					tipo+="REF "+att.Type.Name
	         			else
	         					tipo+=att.Type.Name
          	}
          
        texto=" " + tipo 	
        return texto
  	}
	
	
  	//Generar Atributo y Restriccion NOT NULL
  	
  	eco.Attribute::generateAttribute(){
  	  	print("  " + self.Name + " ")
        print(self.Type.generateType(self,0))
  	}
  	      
  	
  	//Generar Columna y Restriccion NOT NULL
  	
  	eco.Column::generateColumn(){
  	  print("  " + self.Name + " ")
      self.Type.generateType(self,0)
  	}
  	
  	eco.Trigger::generateTrigger() {
	  var ucCount:integer= 0
	  
	  	print("CREATE OR REPLACE TRIGGER " + self.Name + " " + self.Action + " " + self.Event)
	  if(self.updateColumns.size()>0)
	  	{
	  	  print(" OF ")
	  	  self.updateColumns->forEach(c:eco.StructuralComponent)
	  	  {
	  	   ucCount+=1
	  	   print(c.Name)
	  	   if (ucCount< self.updateColumns.size()) print(",")
	  	  }
	  	}
	  println( "\nON " + self.table.Name )
	  print(self.Body)
	  
	}
	
	eco.Package::generatePackage() {
	  var ucCount:integer= 0
	  
	  println("CREATE OR REPLACE PACKAGE " + self.Name + " AS")
	  self.operations->forEach(p:eco.Procedure)
	  {
	    p.generateProcedureHead()
	    println(";")
	  }
	  self.operations->forEach(f:eco.Function)
	  {
	    f.generateFunctionHead()
	    println(";")
	  }
	  println("END "+ self.Name+";")
	  println("")
	  println("CREATE OR REPLACE PACKAGE BODY " + self.Name + " AS")
	  self.operations->forEach(p:eco.Procedure)
	  {
	    p.generateProcedure()
	  }
	  self.operations->forEach(f:eco.Function)
	  {
	    f.generateFunction()
	  }
	  print("END "+ self.Name+";")
	  
	  
	}
	
	eco.Procedure::generateProcedure(){
		  
	   self.generateProcedureHead()
	   println("\nIS")
 	   println (self.Body+";")
	}
	
	eco.Function::generateFunction(){

		self.generateFunctionHead()
	 
	 println("\nIS")
	println(self.Body+";")
	}	
	
	eco.Procedure::generateProcedureHead(){
		  
     var tipo:String
     var pCount:integer = 0
     
	print("PROCEDURE " + self.Name)
	print(" (")
	if(self.operationParameters.size()>0)
	{
	  	
    	self.operationParameters ->forEach(p:eco.OperationParameter )
    	{
    	     if ( p.Type.oclIsKindOf(eco.BasicDataType))
         		  tipo= p.Type.Descriptor
             else {
	         	        tipo=p.Type.Name
          			}
    			print(" "+ p.Mode +" " + p.Name + " " + tipo)
    			pCount+=1
    			if(pCount< self.operationParameters.size())
    				print(",")
 	   }

	}
	   print(" )")
	}
	
  	eco.View::generateView()
  	{
  		println("CREATE OR REPLACE VIEW " + self.Name + " AS")
  		println(" " + self.query_expression + ";")
  	}
	
	eco.Function::generateFunctionHead(){
		  
     var tipo:String
     var pCount:integer = 0

	print("FUNCTION " + self.Name)
	print(" (")
		
	if(self.operationParameters.size()>0)
	{

    	self.operationParameters ->forEach(p:eco.OperationParameter )
    	{
    	     if ( p.Type.oclIsKindOf(eco.BasicDataType))
         		  tipo= p.Type.Descriptor
             else {
	         	        tipo=p.Type.Name
          			}
    			print(" "+ p.Mode +" "+ p.Name + " " + tipo)
    			pCount+=1
    			if(pCount< self.operationParameters.size())
    				print(",")
 	   }

	}
 	print(" )")	
    
    if ( self.Return.oclIsKindOf(eco.BasicDataType))
         		  tipo= self.Return.Descriptor
          else {
	         	tipo=self.Return.Name
          }
	
	 print(" RETURN " +tipo)
	}
  }
}



